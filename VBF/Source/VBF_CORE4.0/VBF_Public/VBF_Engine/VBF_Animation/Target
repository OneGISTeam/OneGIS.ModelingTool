#ifndef OSGANIMATION_TARGET
#define OSGANIMATION_TARGET 1

#include <vector>
#include <Types/VBF_Quat.h>
#include <Types/Vec3>
#include <Types/Vec2>
#include <Types/Vec4>
#include <VBF_Base/VBF_Referenced.h>
#include <VBF_Engine/VBF_Animation/Export>

namespace osgAnimation 
{
	// 执行对象：是频道数据的发送者，它记录场景动画运行的下一个目标值，与预设的权重值结合计算，
	//			并等待接收者接收和执行这个目标
    class Channel;

    class OSGANIMATION_EXPORT Target : public ::CVBF_Referenced
    {
    public:
            
        Target();
        virtual ~Target() {}
        void reset() { _weight = 0; _priorityWeight = 0; }
        int getCount() const { return referenceCount(); }
		// 获取权重
        float getWeight() const { return _weight; }
    protected:
        float _weight;		// 保存权重值的变量
        float _priorityWeight;
        int _lastPriority;
    };


    template <class T>
    class TemplateTarget : public Target
    {
    public:
            
        TemplateTarget() : _target() {}
        TemplateTarget(const T& v) { setValue(v); }
        TemplateTarget(const TemplateTarget& v) { setValue(v.getValue()); }

        inline void lerp(float t, const T& a, const T& b);

        /**
         *  The priority is used to detect a change of priority
         *  It's important to update animation target in priority
         *  order. eg:
         *  all animation with priority 1
         *  all animation with priority 0
         *  all animation with priority -1
         *  ...
         */
		// 将输入值与权重相乘，得到最终的计算结果
        void update(float weight, const T& val, int priority)
        {
            if (_weight || _priorityWeight)
            {
                if (_lastPriority != priority)
                {
                    // change in priority
                    // add to weight with the same previous priority cumulated weight
                    _weight += _priorityWeight * (1.0 - _weight);
                    _priorityWeight = 0;
                    _lastPriority = priority;
                }

                _priorityWeight += weight;
                float t = (1.0 - _weight) * weight / _priorityWeight;
                lerp(t, _target, val);
            }
            else
            {
                _priorityWeight = weight;
                _lastPriority = priority;
                _target = val;
            }
        }
		// 设置/获取最终计算结果的值
        const T& getValue() const { return _target; }
        void setValue(const T& value) { _target = value; }

    protected:

        T _target;  // 保存最终结果的变量
    };

    template <class T>
    inline void TemplateTarget<T>::lerp(float t, const T& a, const T& b)
    {
        _target = a * (1.0f - t) + b * t;
    }

    template <>
    inline void TemplateTarget<osg::Quat>::lerp(float t, const osg::Quat& a, const osg::Quat& b)
    {
        if (a.asVec4() * b.asVec4() < 0.0)
        {
            _target = a * (1.0f - t) + b * -t;
        }
        else
        {
            _target = a * (1.0f - t) + b * t;
        }

        osg::Quat::value_type len2 = _target.length2();
        if ( len2 != 1.0 && len2 != 0.0) 
            _target *= 1.0/sqrt(len2);
    }

    typedef TemplateTarget<osg::Matrixf> MatrixTarget;
    typedef TemplateTarget<osg::Quat> QuatTarget;
    typedef TemplateTarget<osg::Vec3> Vec3Target;
    typedef TemplateTarget<osg::Vec4> Vec4Target;
    typedef TemplateTarget<osg::Vec2> Vec2Target;
    typedef TemplateTarget<float> FloatTarget;
    typedef TemplateTarget<double> DoubleTarget;
  
}

#endif
