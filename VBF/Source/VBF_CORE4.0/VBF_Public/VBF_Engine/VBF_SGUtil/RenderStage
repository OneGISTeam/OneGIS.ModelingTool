#ifndef OSGUTIL_RENDERSTAGE
#define OSGUTIL_RENDERSTAGE 1

#include <VBF_Engine/VBF_SceneGraph/VBFO_StateAttrColorMask.h>
#include <VBF_Engine/VBF_SceneGraph/VBFO_StateAttrViewport.h>
#include <VBF_Engine/VBF_SceneGraph/VBFO_StateAttrTexture.h>
#include <VBF_Engine/VBF_SceneGraph/VBFO_StateAttrFrameBufferObject.h>
#include <VBF_Engine/VBF_SceneGraph/VBF_Camera.h>

#include <VBF_Engine/VBF_SGUtil/RenderBin>
#include <VBF_Engine/VBF_SGUtil/PositionalStateContainer>

namespace osgUtil {

/**
 * RenderStage base class. Used for encapsulate a complete stage in
 * rendering - setting up of viewport, the projection and model
 * matrices and rendering the RenderBin's enclosed with this RenderStage.
 * RenderStage also has a dependency list of other RenderStages, each
 * of which must be called before the rendering of this stage.  These
 * 'pre' rendering stages are used for advanced rendering techniques
 * like multistage pixel shading or impostors.

渲染台："渲染树"的根节点，负责管理默认渲染顺序的所有末端StateGraph节点（附带渲染页），并保存
       了前序渲染和后序渲染的渲染台指针的列表。
渲染后台使用"状态树"来组织和优化节点的渲染状态，此外还有一种用于场景实际渲染的组织结构称之为"渲染树"。
通常来说，后台只有一个渲染树结构，因此应当也只有一个"渲染台"存在；
不过OSG 还提供了“设置摄像机渲染顺序”的功能，即Camera::setRenderOrder。设置为
PRE_RENDER的摄像机子树将在主摄像机之前执行渲染，通常我们可以由此实现诸如"纹理烘焙"的高级功能
（参见osgprerender 例子）；设置为POST_RENDER的摄像机子树将在主摄像机之后执行渲染，一些必须
在最后进行渲染的场景对象，例如HUD显示牌，可以置为这类摄像机的子节点。




 */
class OSGUTIL_EXPORT RenderStage : public RenderBin
{
    public:
    

        RenderStage();
        RenderStage(SortMode mode);
        
        RenderStage(const RenderStage& rhs,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        
        virtual osg::CVBF_Object* cloneType() const { return new RenderStage(); }
        virtual osg::CVBF_Object* clone(const osg::CopyOp& copyop) const { return new RenderStage(*this,copyop); } // note only implements a clone of type.
        virtual bool isSameKindAs(const osg::CVBF_Object* obj) const { return dynamic_cast<const RenderStage*>(obj)!=0L; }
        virtual const char* className() const { return "RenderStage"; }

        virtual void reset();
            
        /** 设置/获取draw buffer，在每帧绘制开始时采用*/
        void setDrawBuffer(GLenum buffer, bool applyMask = true ) { _drawBuffer = buffer; setDrawBufferApplyMask( applyMask ); }
        GLenum getDrawBuffer() const { return _drawBuffer; }

        /** 获取/设置每帧绘制时是否使用DrawBuffer（调用glDrawBuffer） */
        bool getDrawBufferApplyMask() const { return _drawBufferApplyMask; }
        void setDrawBufferApplyMask( bool applyMask ) { _drawBufferApplyMask = applyMask; }


        /** 设置/获取read buffer，在每帧绘制开始时采用*/
        void setReadBuffer(GLenum buffer, bool applyMask = true) { _readBuffer = buffer; setReadBufferApplyMask( applyMask ); }
        GLenum getReadBuffer() const { return _readBuffer; }

 		// 设置获取掩码（是否每帧调用glReadBuffer）
        bool getReadBufferApplyMask() const { return _readBufferApplyMask; }
        void setReadBufferApplyMask( bool applyMask ) { _readBufferApplyMask = applyMask; }


		// 设置/获取视口
        void setViewport(osg::Viewport* viewport) { _viewport = viewport; }
        const osg::Viewport* getViewport() const { return _viewport.get(); }
        osg::Viewport* getViewport() { return _viewport.get(); }
        
		// 设置/获取初始的视口矩阵
        void setInitialViewMatrix(const osg::RefMatrix* matrix) { _initialViewMatrix = matrix; }
        const osg::RefMatrix* getInitialViewMatrix() { return _initialViewMatrix.get(); }

  		// 设置清除背景的掩码（在glClear（）中调用，默认值为GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT）
        void setClearMask(GLbitfield mask) { _clearMask = mask; }
        GLbitfield getClearMask() const { return _clearMask; }


        void setColorMask(osg::ColorMask* cm) { _colorMask = cm; }
        osg::ColorMask* getColorMask() { return _colorMask.get(); }
        const osg::ColorMask* getColorMask() const { return _colorMask.get(); }

		// 设置/获取清屏颜色，用于glClearColor(..)，glClearColor仅在mask & GL_COLOR_BUFFER_BIT为真时被调用
        void setClearColor(const osg::Vec4& color) { _clearColor=color; }
        const osg::Vec4& getClearColor() const { return _clearColor; }
        
        /** Set the clear accum used in glClearAccum(..). 
          * glClearAcumm is only called if mask & GL_ACCUM_BUFFER_BIT is true. */
        void setClearAccum(const osg::Vec4& color) { _clearAccum=color; }
        
        /** Get the clear accum.*/
        const osg::Vec4& getClearAccum() const { return _clearAccum; }
        
        /** Set the clear depth used in glClearDepth(..). Defaults to 1.0
          * glClearDepth is only called if mask & GL_DEPTH_BUFFER_BIT is true. */
        void setClearDepth(double depth) { _clearDepth=depth; }
        
        /** Get the clear depth.*/
        double getClearDepth() const { return _clearDepth; }

        /** Set the clear stencil value used in glClearStencil(). Defaults to 0;
          * glClearStencil is only called if mask & GL_STENCIL_BUFFER_BIT is true*/
        void setClearStencil(int stencil) { _clearStencil=stencil; }
        
        /** Get the clear color.*/
        int getClearStencil() const { return _clearStencil; }
        

        void setCamera(osg::IVBF_Camera* camera) { if (_camera!=camera) { _camera = camera; _cameraRequiresSetUp = true; } }
        osg::IVBF_Camera* getCamera() { return _camera; }
        const osg::IVBF_Camera* getCamera() const { return _camera; }

        void setCameraRequiresSetUp(bool flag) { _cameraRequiresSetUp = flag; }
        bool getCameraRequiresSetUp() const { return _cameraRequiresSetUp; }
        
        /** Attempt the set the RenderStage from the Camera settings.*/
        void runCameraSetUp(osg::RenderInfo& renderInfo);
        
        void setTexture(osg::Texture* texture, unsigned int level = 0, unsigned int face=0) { _texture = texture; _level = level; _face = face; }
        osg::Texture* getTexture() { return _texture.get(); }
        
        void setImage(osg::Image* image) { _image = image; }
        osg::Image* getImage() { return _image.get(); }
        
        void setImageReadPixelFormat(GLenum format) { _imageReadPixelFormat = format; }
        GLenum getImageReadPixelFormat() const { return _imageReadPixelFormat; }

        void setImageReadPixelDataType(GLenum type) { _imageReadPixelDataType = type; }
        GLenum getImageReadPixelDataType() const { return _imageReadPixelDataType; }

        /** Set a framebuffer object to render into. It is permissible for the
          * framebuffer object to be multisampled, in which case you should also
          * set a resolve framebuffer object - see setMultisampleResolveFramebufferObject(). */
        void setFrameBufferObject(osg::FrameBufferObject* fbo) { _fbo = fbo; }
        osg::FrameBufferObject* getFrameBufferObject() { return _fbo.get(); }
        const osg::FrameBufferObject* getFrameBufferObject() const { return _fbo.get(); }

        /** Sets the destination framebuffer object for glBlitFramebufferEXT to
          * resolve a multisampled framebuffer object after the RenderStage is
          * drawn. The resolve framebuffer object must not be multisampled. The
          * resolve framebuffer object is only necessary if the primary framebuffer
          * object is multisampled, if not then leave it set to null. */
        void setMultisampleResolveFramebufferObject(osg::FrameBufferObject* fbo);
        osg::FrameBufferObject* getMultisampleResolveFramebufferObject() { return _resolveFbo.get(); }
        const osg::FrameBufferObject* getMultisampleResolveFramebufferObject() const { return _resolveFbo.get(); }

        /** Set whether the framebuffer object should be unbound after
          * rendering. By default this is set to true. Set it to false if the
          * unbinding is not required. */
        void setDisableFboAfterRender(bool disable) {_disableFboAfterRender = disable;}
        bool getDisableFboAfterRender() const {return _disableFboAfterRender;}

        void setGraphicsContext(osg::GraphicsContext* context) { _graphicsContext = context; }
        osg::GraphicsContext* getGraphicsContext() { return _graphicsContext.get(); }
        const osg::GraphicsContext* getGraphicsContext() const { return _graphicsContext.get(); }




        void setInheritedPositionalStateContainerMatrix(const osg::Matrix& matrix) { _inheritedPositionalStateContainerMatrix = matrix; }
        const osg::Matrix& getInheritedPositionalStateContainerMatrix() const { return _inheritedPositionalStateContainerMatrix; }

        void setInheritedPositionalStateContainer(PositionalStateContainer* rsl) { _inheritedPositionalStateContainer = rsl; }
        PositionalStateContainer* getInheritedPositionalStateContainer() { return _inheritedPositionalStateContainer.get(); }

        void setPositionalStateContainer(PositionalStateContainer* rsl) { _renderStageLighting = rsl; }

        PositionalStateContainer* getPositionalStateContainer() const
        {
            if (!_renderStageLighting.valid()) _renderStageLighting = new PositionalStateContainer;
            return _renderStageLighting.get();
        }

        virtual void addPositionedAttribute(osg::RefMatrix* matrix,const osg::StateAttribute* attr)
        {
            getPositionalStateContainer()->addPositionedAttribute(matrix,attr);
        }
        
        virtual void addPositionedTextureAttribute(unsigned int textureUnit, osg::RefMatrix* matrix,const osg::StateAttribute* attr)
        {
            getPositionalStateContainer()->addPositionedTextureAttribute(textureUnit, matrix,attr);
        }

        void copyTexture(osg::RenderInfo& renderInfo);

        virtual void sort();
        
        virtual void drawPreRenderStages(osg::RenderInfo& renderInfo,RenderLeaf*& previous);

        virtual void draw(osg::RenderInfo& renderInfo,RenderLeaf*& previous);

        virtual void drawInner(osg::RenderInfo& renderInfo,RenderLeaf*& previous, bool& doCopyTexture);
    
        virtual void drawPostRenderStages(osg::RenderInfo& renderInfo,RenderLeaf*& previous);

        virtual void drawImplementation(osg::RenderInfo& renderInfo,RenderLeaf*& previous);


        void addToDependencyList(RenderStage* rs) { addPreRenderStage(rs); }

        void addPreRenderStage(RenderStage* rs, int order = 0);
        
        void addPostRenderStage(RenderStage* rs, int order = 0);

        /** Extract stats for current draw list. */
        bool getStats(Statistics& stats) const; 
 
        /** Compute the number of dynamic RenderLeaves.*/
        virtual unsigned int computeNumberOfDynamicRenderLeaves() const;

        struct Attachment
        {
            ref_ptr<osg::Image>                _image;
            GLenum                                  _imageReadPixelFormat;
            GLenum                                  _imageReadPixelDataType;
        };

        void attach(osg::Camera::BufferComponent buffer, osg::Image* image);

        /** search through any pre and post RenderStage that reference a Camera, and take a reference to each of these cameras to prevent them being deleted while they are still be used by the drawing thread.*/
        void collateReferencesToDependentCameras();

        /** clear the references to any dependent cameras.*/
        void clearReferencesToDependentCameras();

        /** If State is non-zero, this function releases any associated OpenGL objects for
           * the specified graphics context. Otherwise, releases OpenGL objexts
           * for all graphics contexts. */
        virtual void releaseGLObjects(osg::State* state= 0) const;

protected:

        virtual ~RenderStage();

        typedef std::pair< int , ref_ptr<RenderStage> > RenderStageOrderPair;
        typedef std::list< RenderStageOrderPair > RenderStageList;
        typedef std::vector< ref_ptr<osg::IVBF_Camera> > Cameras;

        bool                                _stageDrawnThisFrame;
        RenderStageList                     _preRenderList;
        RenderStageList                     _postRenderList;

        Cameras                             _dependentCameras;

        // viewport x,y,width,height.
        ref_ptr<osg::Viewport>         _viewport;
        ref_ptr<const osg::RefMatrix>  _initialViewMatrix;
        
        GLenum                              _drawBuffer;
        bool                                _drawBufferApplyMask;
        GLenum                              _readBuffer;
        bool                                _readBufferApplyMask;
        GLbitfield                          _clearMask;
        ref_ptr<osg::ColorMask>        _colorMask;
        osg::Vec4                           _clearColor;
        osg::Vec4                           _clearAccum;
        double                              _clearDepth;
        int                                 _clearStencil;

        bool                                _cameraRequiresSetUp;
        osg::IVBF_Camera*                  _camera;
        
        ref_ptr<osg::Texture>              _texture;
        unsigned int                            _level;
        unsigned int                            _face;

        ref_ptr<osg::Image>                _image;
        GLenum                                  _imageReadPixelFormat;
        GLenum                                  _imageReadPixelDataType;
        
        std::map< osg::Camera::BufferComponent, Attachment> _bufferAttachmentMap;
        
        ref_ptr<osg::FrameBufferObject>    _fbo;
        ref_ptr<osg::FrameBufferObject>    _resolveFbo;
        ref_ptr<osg::GraphicsContext>      _graphicsContext;
        bool                                    _disableFboAfterRender;

        mutable osg::Matrix                         _inheritedPositionalStateContainerMatrix;
        mutable ref_ptr<PositionalStateContainer>   _inheritedPositionalStateContainer;
        mutable ref_ptr<PositionalStateContainer>   _renderStageLighting;


};

}

#endif

