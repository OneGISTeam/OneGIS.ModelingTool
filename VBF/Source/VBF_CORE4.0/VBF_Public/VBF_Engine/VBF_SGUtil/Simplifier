#ifndef OSGUTIL_SIMPLIFIER
#define OSGUTIL_SIMPLIFIER 1

#include <VBF_Engine/VBF_SceneGraph/VBF_SGNVisitOp.h>
#include <VBF_Engine/VBF_SceneGraph/IVBF_SGNodeGeometry.h>
#include <VBF_Engine/VBF_SceneGraph/VBFO_SGDrawableGeometry.h>

#include <VBF_Engine/VBF_SGUtil/Export>

namespace osgUtil {

// 简化操作器：减少osg::Geometry中三角形的数量 ，采用的是边塌陷算法
//            对几何体简化主要需要设置两个方面的参数，即当几何体样本比率小于1时，设置点的误差限制；
//			  当几何体样本比率大于1时，设置边的长度限制。通过对点的误差和边的长度的限制简化不必要
//			  的点和边
class OSGUTIL_EXPORT Simplifier : public osg::NodeVisitor
{
    public:

		// sampleRatio 样本比率：样本比率越大，简化越小
		// maximumError点的最大误差：
        Simplifier(double sampleRatio=1.0, double maximumError=FLT_MAX, double maximumLength=0.0);

        META_NodeVisitor("osgUtil","Simplifier")

		// 设置样本比率
        void setSampleRatio(float sampleRatio) { _sampleRatio = sampleRatio; }
        float getSampleRatio() const { return _sampleRatio; }

		// 设置最大点误差，所有点的移动必须小于允许的点移动量，仅当sampleRatio < 1.0时有效
        void setMaximumError(float error) { _maximumError = error; }
        float getMaximumError() const { return _maximumError; }

		// 设置最大边长限制，简化后所有的都要比限制的边长短，仅当sampleRatio > 1.0时有效
        void setMaximumLength(float length) { _maximumLength = length; }
        float getMaximumLength() const { return _maximumLength; }

		// 
        void setDoTriStrip(bool on) { _triStrip = on; }
        bool getDoTriStrip() const { return _triStrip; }

        void setSmoothing(bool on) { _smoothing = on; }
        bool getSmoothing() const { return _smoothing; }
        
        class ContinueSimplificationCallback : public ::CVBF_Referenced
        {
            public:
                /** return true if mesh should be continued to be simplified, return false to stop simplification.*/
                virtual bool continueSimplification(const Simplifier& simplifier, float nextError, unsigned int numOriginalPrimitives, unsigned int numRemainingPrimitives) const
                {
                    return simplifier.continueSimplificationImplementation(nextError, numOriginalPrimitives, numRemainingPrimitives);
                }
            
            protected:
                virtual ~ContinueSimplificationCallback() {}
        };
        
        void setContinueSimplificationCallback(ContinueSimplificationCallback* cb) { _continueSimplificationCallback = cb; }
        ContinueSimplificationCallback* getContinueSimplificationCallback() { return _continueSimplificationCallback.get(); }
        const ContinueSimplificationCallback* getContinueSimplificationCallback() const { return _continueSimplificationCallback.get(); }
        
        
        bool continueSimplification(float nextError, unsigned int numOriginalPrimitives, unsigned int numRemainingPrimitives) const
        {
            if (_continueSimplificationCallback.valid()) return _continueSimplificationCallback->continueSimplification(*this, nextError, numOriginalPrimitives, numRemainingPrimitives);
            else return continueSimplificationImplementation(nextError, numOriginalPrimitives, numRemainingPrimitives);
        }

        virtual bool continueSimplificationImplementation(float nextError, unsigned int numOriginalPrimitives, unsigned int numRemainingPrimitives) const
        {
            if (getSampleRatio()<1.0) return ((float)numRemainingPrimitives > ((float)numOriginalPrimitives) * getSampleRatio()) && nextError<=getMaximumError();
            else return ((float)numRemainingPrimitives < ((float)numOriginalPrimitives) * getSampleRatio()) && nextError>getMaximumLength();
        }


        virtual void apply(osg::IVBF_SGNodeGeometry& geode)
        {
            for(unsigned int i=0;i<geode.getNumDrawables();++i)
            {
                osg::Geometry* geometry = geode.getDrawable(i)->asGeometry();
                if (geometry)
                {
                    simplify(*geometry);
                }
            }
        }

        // 简化几何体
        void simplify(osg::Geometry& geometry);
        
        typedef std::vector<unsigned int> IndexList; /// a list of point indices

        // 简化几何体，同时保护关键点不被简化
        void simplify(osg::Geometry& geometry, const IndexList& protectedPoints);


    protected:
    
        double _sampleRatio;
        double _maximumError;
        double _maximumLength;
        bool  _triStrip;
        bool  _smoothing;
        
        ref_ptr<ContinueSimplificationCallback> _continueSimplificationCallback;
    
};


}

#endif
