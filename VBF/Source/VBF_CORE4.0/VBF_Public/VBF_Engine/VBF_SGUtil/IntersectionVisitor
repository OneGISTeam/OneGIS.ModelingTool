#ifndef OSGUTIL_INTERSECTIONVISITOR
#define OSGUTIL_INTERSECTIONVISITOR 1

#include <VBF_Engine/VBF_SceneGraph/VBF_SGNVisitOp.h>
#include <VBF_Engine/VBF_SceneGraph/VBFO_SGDrawable.h>
#include <VBF_Engine/VBF_SGUtil/Export>
#include <VBF_Engine/VBF_SGUtil/Intersector>
#include <list>

namespace osgUtil
{

class IntersectionVisitor;


// 求交器，纯虚类，定义了相交测试的接口
class Intersector : public ::CVBF_Referenced
{
    public:

        enum CoordinateFrame
        {
            WINDOW,
            PROJECTION,
            VIEW,
            MODEL
        };

        enum IntersectionLimit
        {
            NO_LIMIT,
            LIMIT_ONE_PER_DRAWABLE,
            LIMIT_ONE,
            LIMIT_NEAREST
        };

        Intersector(CoordinateFrame cf=MODEL):
            _coordinateFrame(cf),
            _intersectionLimit(NO_LIMIT),
            _disabledCount(0)
        {

        }


        void setCoordinateFrame(CoordinateFrame cf) { _coordinateFrame = cf; }
        CoordinateFrame getCoordinateFrame() const { return _coordinateFrame; }

        void setIntersectionLimit(IntersectionLimit limit) { _intersectionLimit = limit; }
        IntersectionLimit getIntersectionLimit() const { return _intersectionLimit; }

        virtual Intersector* clone(osgUtil::IntersectionVisitor& iv) = 0;

        virtual bool enter(const osg::IVBF_SGNode& node) = 0;
        virtual void leave() = 0;

        virtual void intersect(osgUtil::IntersectionVisitor& iv, osg::Drawable* drawable) = 0;

        virtual void reset() { _disabledCount = 0; }

        virtual bool containsIntersections() = 0;

        inline bool disabled() const { return _disabledCount!=0; }

        inline void incrementDisabledCount() { ++_disabledCount; }
        inline void decrementDisabledCount() { if (_disabledCount>0) --_disabledCount; }

        inline bool reachedLimit() { return _intersectionLimit == LIMIT_ONE && containsIntersections(); }

   protected:

        CoordinateFrame   _coordinateFrame;
        IntersectionLimit _intersectionLimit;
        unsigned int      _disabledCount;

};

// 传递多个求交器（intersectors）到场景图， 与IntersectionVisitor结合使用
class OSGUTIL_EXPORT IntersectorGroup : public Intersector
{
    public:
        IntersectorGroup();

        void addIntersector(Intersector* intersector);

        typedef std::vector< ref_ptr<Intersector> > Intersectors;
        Intersectors& getIntersectors() { return _intersectors; }

        void clear();

    public:
        virtual Intersector* clone(osgUtil::IntersectionVisitor& iv);
        virtual bool enter(const osg::IVBF_SGNode& node);
        virtual void leave();
        virtual void intersect(osgUtil::IntersectionVisitor& iv, osg::Drawable* drawable);
        virtual void reset();
        virtual bool containsIntersections();

    protected:
        Intersectors _intersectors;

};


// 求交访问器，用于测试与场景的交点。遍历场景使用求交器（Intersector）进行相交测试
// 为了实现不同的求交技术，首先实现求交器（Intersector）
class OSGUTIL_EXPORT IntersectionVisitor : public osg::NodeVisitor
{
    public:

        /** Callback used to implement the reading of external files, allowing support for paged databases to be
          * integrated with IntersectionVisitor.  A concrete implementation can be found in osgDB.
          * Note, this loose coupling approach is required as osgUtil is independent from osgDB where the file reading
          * is implemented, and osgDB itself is dependent upon osgUtil so a circular dependency would result from
          * tighter integration.*/
        struct ReadCallback : public ::CVBF_Referenced
        {
            virtual osg::IVBF_SGNode* readNodeFile(const std::string& filename) = 0;
        };


        IntersectionVisitor(Intersector* intersector=0, ReadCallback* readCallback=0);

        META_NodeVisitor("osgUtil","IntersectionVisitor")

        virtual void reset();


        // 设置/获取求交器，该求交器用于实现和场景的相交计算并记录交点
        void setIntersector(Intersector* intersector);
        Intersector* getIntersector() { return _intersectorStack.empty() ? 0 : _intersectorStack.front().get(); }
        const Intersector* getIntersector() const { return _intersectorStack.empty() ? 0 : _intersectorStack.front().get(); }


        // 设置/获取是否使用KdTrees（如果场景图中存在）
        void setUseKdTreeWhenAvailable(bool useKdTrees) { _useKdTreesWhenAvailable = useKdTrees; }
        bool getUseKdTreeWhenAvailable() const { return _useKdTreesWhenAvailable; }

        void setDoDummyTraversal(bool dummy) { _dummyTraversal = dummy; }
        bool getDoDummyTraversal() const { return _dummyTraversal; }


        // 设置/获取read callback
        void setReadCallback(ReadCallback* rc) { _readCallback = rc; }
        ReadCallback* getReadCallback() { return _readCallback.get(); }
        const ReadCallback* getReadCallback() const { return _readCallback.get(); }


        void pushWindowMatrix(osg::RefMatrix* matrix) { _windowStack.push_back(matrix); _eyePointDirty = true; }
        void pushWindowMatrix(osg::Viewport* viewport) { _windowStack.push_back(new osg::RefMatrix( viewport->computeWindowMatrix()) ); _eyePointDirty = true; }
        void popWindowMatrix() { _windowStack.pop_back(); _eyePointDirty = true; }
        osg::RefMatrix* getWindowMatrix() { return _windowStack.empty() ? 0 :  _windowStack.back().get(); }
        const osg::RefMatrix* getWindowMatrix() const { return _windowStack.empty() ? 0 :  _windowStack.back().get(); }

        void pushProjectionMatrix(osg::RefMatrix* matrix) { _projectionStack.push_back(matrix); _eyePointDirty = true; }
        void popProjectionMatrix() { _projectionStack.pop_back(); _eyePointDirty = true; }
        osg::RefMatrix* getProjectionMatrix() { return _projectionStack.empty() ? 0 :  _projectionStack.back().get(); }
        const osg::RefMatrix* getProjectionMatrix() const { return _projectionStack.empty() ? 0 :  _projectionStack.back().get(); }

        void pushViewMatrix(osg::RefMatrix* matrix) { _viewStack.push_back(matrix); _eyePointDirty = true; }
        void popViewMatrix() { _viewStack.pop_back(); _eyePointDirty = true; }
        osg::RefMatrix* getViewMatrix() { return _viewStack.empty() ? 0 :  _viewStack.back().get(); }
        const osg::RefMatrix* getViewMatrix() const { return _viewStack.empty() ? 0 :  _viewStack.back().get(); }

        void pushModelMatrix(osg::RefMatrix* matrix) { _modelStack.push_back(matrix); _eyePointDirty = true; }
        void popModelMatrix() { _modelStack.pop_back(); _eyePointDirty = true; }
        osg::RefMatrix* getModelMatrix() { return _modelStack.empty() ? 0 :  _modelStack.back().get(); }
        const osg::RefMatrix* getModelMatrix() const { return _modelStack.empty() ? 0 :  _modelStack.back().get(); }


        /** Set the reference eye point that is used for nodes that require an eye point to position themselves, such as billboards.*/
        void setReferenceEyePoint(const osg::Vec3& ep) { _referenceEyePoint = ep; _eyePointDirty = true; }

        /** Get the reference eye point.*/
        const osg::Vec3& getReferenceEyePoint() const { return _referenceEyePoint; }

        /** Set the coordinate frame of the reference eye point.*/
        void setReferenceEyePointCoordinateFrame(Intersector::CoordinateFrame cf) { _referenceEyePointCoordinateFrame = cf; }

        /** Get the coordinate frame of the reference eye point.*/
        Intersector::CoordinateFrame getReferenceEyePointCoordinateFrame() const { return _referenceEyePointCoordinateFrame; }


        /** Get the eye point in the local coordinate frame a given traversal point.*/
        virtual osg::Vec3 getEyePoint() const;

        enum LODSelectionMode
        {
            USE_HIGHEST_LEVEL_OF_DETAIL,
            USE_EYE_POINT_FOR_LOD_LEVEL_SELECTION
        };

        /** Set the LOD selection scheme.*/
        void setLODSelectionMode(LODSelectionMode mode) { _lodSelectionMode = mode; }

        /** Get the LOD selection scheme.*/
        LODSelectionMode getLODSelectionMode() const { return _lodSelectionMode; }

         /** Get the distance from a point to the eye point, distance value in local coordinate system.
          * This is calculated using the pseudo-EyePoint (above) when doing LOD calculcations. */
        virtual float getDistanceToEyePoint(const osg::Vec3& pos, bool withLODScale) const;

    public:

        virtual void apply(osg::IVBF_SGNode& node);
        virtual void apply(osg::IVBF_SGNodeGeometry& geode);
        virtual void apply(osg::IVBF_SGNodeGeometryBillboard& geode);
        virtual void apply(osg::IVBF_SGNodeGroup& group);
        virtual void apply(osg::IVBF_SGNodeGroupLOD& lod);
        virtual void apply(osg::IVBF_SGNodeGroupLODPaged& lod);
        virtual void apply(osg::IVBF_SGNodeGroupTransform& transform);
        virtual void apply(osg::IVBF_SGNodeGroupProjection& projection);
        virtual void apply(osg::IVBF_Camera& camera);

    protected:

        inline bool enter(const osg::IVBF_SGNode& node) { return _intersectorStack.empty() ? false : _intersectorStack.back()->enter(node); }
        inline void leave() { _intersectorStack.back()->leave(); }
        inline void intersect(osg::Drawable* drawable) { _intersectorStack.back()->intersect(*this, drawable); }
        inline void push_clone() { _intersectorStack.push_back ( _intersectorStack.front()->clone(*this) ); }
        inline void pop_clone() { if (_intersectorStack.size()>=2) _intersectorStack.pop_back(); }

        typedef std::list< ref_ptr<Intersector> > IntersectorStack;
        IntersectorStack _intersectorStack;

        bool _useKdTreesWhenAvailable;
        bool _dummyTraversal;

        ref_ptr<ReadCallback> _readCallback;

        typedef std::list< ref_ptr<osg::RefMatrix> > MatrixStack;
        MatrixStack _windowStack;
        MatrixStack _projectionStack;
        MatrixStack _viewStack;
        MatrixStack _modelStack;

        osg::Vec3                       _referenceEyePoint;
        Intersector::CoordinateFrame    _referenceEyePointCoordinateFrame;
        LODSelectionMode                _lodSelectionMode;

        mutable bool                    _eyePointDirty;
        mutable osg::Vec3               _eyePoint;
};

}

#endif

